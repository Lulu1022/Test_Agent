---
name: openspec-onboard
description: OpenSpec 引導式入門——以解說與實際程式庫操作走完一輪完整流程。
license: MIT
compatibility: 需要 openspec CLI。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

引導使用者完成第一次完整的 OpenSpec 流程週期。這是教學體驗——會在他們的程式庫中做真實工作，同時說明每一步。

---

## 起飛前檢查

開始前檢查 OpenSpec 是否已初始化：

```bash
openspec status --json 2>&1 || echo "NOT_INITIALIZED"
```

**若未初始化：**
> 此專案尚未設定 OpenSpec。請先執行 `openspec init`，再回來用 `/opsx:onboard`。

未初始化則在此停止。

---

## 第一階段：歡迎

顯示：

```
## 歡迎使用 OpenSpec！

我會用你程式庫裡的一個真實任務，帶你走完一輪完整的變更週期——從想法到實作。過程中你會透過實際操作學會流程。

**我們會做的事：**
1. 在程式庫裡選一個小任務
2. 簡短探索問題
3. 建立一個變更（工作的容器）
4. 建立產物：proposal → specs → design → tasks
5. 實作任務
6. 封存完成的變更

**時間：** 約 15–20 分鐘

先來找一件事來做。
```

---

## 第二階段：任務選擇

### 程式庫分析

掃描程式庫找小改進機會。尋找：

1. **TODO/FIXME 註解**：在程式檔中搜尋 `TODO`、`FIXME`、`HACK`、`XXX`
2. **缺少錯誤處理**：吞掉錯誤的 `catch`、沒有 try-catch 的風險操作
3. **沒有測試的函式**：對照 `src/` 與測試目錄
4. **型別問題**：TypeScript 中的 `any`（`: any`、`as any`）
5. **除錯殘留**：非除錯程式中的 `console.log`、`console.debug`、`debugger`
6. **缺少驗證**：未驗證使用者輸入的處理邏輯

也可檢查最近 git 活動：
```bash
git log --oneline -10 2>/dev/null || echo "No git history"
```

### 呈現建議

根據分析呈現 3–4 個具體建議：

```
## 任務建議

根據對程式庫的掃描，以下是幾個適合入門的任務：

**1. [最推薦的任務]**
   位置：`src/path/to/file.ts:42`
   範圍：約 1–2 個檔案，約 20–30 行
   為何適合：[簡短理由]

**2. [第二個任務]**
   位置：`src/another/file.ts`
   範圍：約 1 個檔案，約 15 行
   為何適合：[簡短理由]

**3. [第三個任務]**
   位置：[位置]
   範圍：[估計]
   為何適合：[簡短理由]

**4. 其他？**
   告訴我想做什麼。

哪個任務有興趣？（選編號或描述你自己的）
```

**若沒找到：** 改為詢問使用者想建什麼：
> 在程式庫裡沒找到明顯的小改進。有什麼你一直想加或想修的小東西嗎？

### 範圍護欄

若使用者選了或描述了過大的任務（大功能、多日工作）：

```
那是很有價值的任務，但對第一次跑 OpenSpec 可能偏大。

學流程時，越小越好——可以完整走完一輪而不卡在實作細節。

**選項：**
1. **切小一點**——[他們的任務] 最小可用的那一塊是什麼？也許只做 [具體切片]？
2. **選別的**——上面其他建議，或另一個小任務？
3. **照做**——若真的想做這個，也可以。只是會花比較久。

你比較想哪一個？
```

若使用者堅持可放行——這是軟性護欄。

---

## 第三階段：探索示範

選定任務後，簡短示範探索模式：

```
在建立變更之前，先快速示範 **探索模式**——這是你在定案方向前先想清楚問題的方式。
```

花 1–2 分鐘調查相關程式碼：
- 讀取相關檔案
- 有助益時畫簡短 ASCII 圖
- 註記任何考量

```
## 簡短探索

[你的簡短分析——發現了什麼、有何考量]

┌─────────────────────────────────────────┐
│   [可選：有助益的 ASCII 圖]             │
└─────────────────────────────────────────┘

探索模式（`/opsx:explore`）就是做這種思考——實作前先調查。需要想清楚問題時隨時可用。

接下來我們建立一個變更來承載我們的工作。
```

**暫停**——等使用者表示再繼續。

---

## 第四階段：建立變更

**說明：**
```
## 建立變更

OpenSpec 的「變更」是一塊工作相關的思考與規劃的容器。它放在 `openspec/changes/<name>/`，裡面有你的產物——proposal、specs、design、tasks。

我來為我們的任務建一個。
```

**執行：** 用推導出的 kebab-case 名稱建立變更：
```bash
openspec new change "<derived-name>"
```

**顯示：**
```
已建立：`openspec/changes/<name>/`

資料夾結構：
openspec/changes/<name>/
├── proposal.md    ← 為何做這件事（空的，我們會填）
├── design.md      ← 怎麼建（空的）
├── specs/         ← 詳細需求（空的）
└── tasks.md       ← 實作檢查表（空的）

接下來填第一個產物——proposal。
```

---

## 第五階段：Proposal

**說明：**
```
## Proposal

Proposal 記錄我們**為何**做這個變更、**什麼**會受影響（高層）。是這份工作的「電梯簡報」。

我會根據我們的任務起草一份。
```

**執行：** 起草 proposal 內容（先不存檔）：

```
這是 proposal 草稿：

---

## Why（為何）

[1–2 句說明問題/機會]

## What Changes（什麼會變）

[會不一樣的項目]

## Capabilities

### 新 Capabilities
- `<capability-name>`：[簡短描述]

### 修改的 Capabilities
<!-- 若有修改既有行為 -->

## Impact（影響）

- `src/path/to/file.ts`：[會怎麼變]
- [其他檔案若適用]

---

有抓到意圖嗎？存檔前可以再調整。
```

**暫停**——等使用者同意或回饋。

同意後存檔：
```bash
openspec instructions proposal --change "<name>" --json
```
然後將內容寫入 `openspec/changes/<name>/proposal.md`。

```
Proposal 已存。這是你的「為何」文件——理解演進時隨時可以回來改。

下一步：specs。
```

---

## 第六階段：Specs

**說明：**
```
## Specs

Spec 用精確、可測試的方式定義我們**要建什麼**。用 requirement/scenario 格式讓預期行為很清楚。

像這樣的小任務，可能只需要一個 spec 檔。
```

**執行：** 建立 spec 檔：
```bash
mkdir -p openspec/changes/<name>/specs/<capability-name>
```

起草 spec 內容：

```
這是 spec：

---

## ADDED Requirements

### Requirement: <名稱>

<系統應做什麼的描述>

#### Scenario: <Scenario 名稱>

- **WHEN** <觸發條件>
- **THEN** <預期結果>
- **AND** <若有額外結果>

---

這種 WHEN/THEN/AND 格式讓需求可測試。可以直接當測試案例讀。
```

存到 `openspec/changes/<name>/specs/<capability>/spec.md`。

---

## 第七階段：Design

**說明：**
```
## Design

Design 記錄我們**怎麼**建——技術決策、取捨、做法。

小變更可能很簡短。沒關係——不是每個變更都要深入設計討論。
```

**執行：** 起草 design.md：

```
這是 design：

---

## Context（脈絡）

[目前狀態的簡短脈絡]

## Goals / Non-Goals

**Goals：**
- [要達成的目標]

**Non-Goals：**
- [明確排除在外的範圍]

## Decisions

### Decision 1：[關鍵決策]

[做法與理由說明]

---

對小任務來說，這樣就抓住關鍵決策，又不會過度設計。
```

存到 `openspec/changes/<name>/design.md`。

---

## 第八階段：Tasks

**說明：**
```
## Tasks

最後把工作拆成實作任務——驅動 apply 階段的勾選框。

應該要小、清楚、順序合理。
```

**執行：** 依 specs 與 design 產生任務：

```
這是實作任務：

---

## 1. [類別或檔案]

- [ ] 1.1 [具體任務]
- [ ] 1.2 [具體任務]

## 2. 驗證

- [ ] 2.1 [驗證步驟]

---

每個勾選框在 apply 階段就是一個工作單位。準備實作了嗎？
```

**暫停**——等使用者確認要實作。

存到 `openspec/changes/<name>/tasks.md`。

---

## 第九階段：Apply（實作）

**說明：**
```
## 實作

現在我們逐項實作任務，邊做邊打勾。我會說明每一項，偶爾提到 specs/design 如何影響做法。
```

**執行：** 對每個任務：

1. 宣告：「進行任務 N：[描述]」
2. 在程式庫中實作變更
3. 自然引用 specs/design：「規格說 X，所以我做 Y」
4. 在 tasks.md 標為完成：`- [ ]` → `- [x]`
5. 簡短狀態：「✓ 任務 N 完成」

解說保持輕量——不要每行程式都解釋。

全部任務完成後：

```
## 實作完成

所有任務完成：
- [x] 任務 1
- [x] 任務 2
- [x] ...

變更已實作！還差一步——我們來封存它。
```

---

## 第十階段：封存

**說明：**
```
## 封存

變更完成後我們會封存。這會把它從 `openspec/changes/` 移到 `openspec/changes/archive/YYYY-MM-DD-<name>/`。

封存的變更成為專案的決策歷史——之後隨時可以回頭了解當初為什麼這樣建。
```

**執行：**
```bash
openspec archive "<name>"
```

**顯示：**
```
已封存至：`openspec/changes/archive/YYYY-MM-DD-<name>/`

變更已是專案歷史的一部分。程式在程式庫裡，決策記錄也保留了。
```

---

## 第十一階段：回顧與下一步

```
## 恭喜！

你剛完成一輪完整的 OpenSpec 週期：

1. **Explore**：想清楚問題
2. **New**：建立變更容器
3. **Proposal**：記錄為何
4. **Specs**：詳細定義什麼
5. **Design**：決定怎麼做
6. **Tasks**：拆成步驟
7. **Apply**：實作
8. **Archive**：保留記錄

同樣的節奏適用任何大小的變更——小修或大功能都一樣。

---

## 指令速查

| 指令 | 用途 |
|------|------|
| `/opsx:explore` | 工作前/工作中先想清楚問題 |
| `/opsx:new` | 開始新變更，逐步建立產物 |
| `/opsx:ff` | 快轉：一次建立所有產物 |
| `/opsx:continue` | 繼續進行既有變更 |
| `/opsx:apply` | 實作變更的任務 |
| `/opsx:verify` | 驗證實作是否符合產物 |
| `/opsx:archive` | 封存完成的變更 |

---

## 下一步？

對你真正想做的東西試試 `/opsx:new` 或 `/opsx:ff`。節奏你已經會了！
```

---

## 優雅結束處理

### 使用者中途想停

若使用者說要停、要暫停，或顯得不想繼續：

```
沒問題！你的變更已存在 `openspec/changes/<name>/`。

之後要接下去：
- `/opsx:continue <name>`：繼續建立產物
- `/opsx:apply <name>`：跳到實作（若有任務）

工作不會不見。隨時回來即可。
```

不施壓、優雅結束。

### 使用者只要指令速查

若使用者說只要看指令或跳過教學：

```
## OpenSpec 速查

| 指令 | 用途 |
|------|------|
| `/opsx:explore` | 想清楚問題（不改程式） |
| `/opsx:new <name>` | 開始新變更，逐步 |
| `/opsx:ff <name>` | 快轉：一次建完產物 |
| `/opsx:continue <name>` | 繼續既有變更 |
| `/opsx:apply <name>` | 實作任務 |
| `/opsx:verify <name>` | 驗證實作 |
| `/opsx:archive <name>` | 完成後封存 |

想開始第一個變更用 `/opsx:new`，想快一點用 `/opsx:ff`。
```

優雅結束。

---

## 護欄

- **關鍵轉折採用「說明 → 執行 → 顯示 → 暫停」**（探索後、proposal 草稿後、tasks 後、封存後）
- **實作時解說保持輕量**——教但不說教
- **不跳階段**——即使變更很小，目標是教流程
- **在標記處暫停等確認**，但不要過度暫停
- **優雅處理結束**——絕不施壓繼續
- **用真實程式庫任務**——不模擬或假範例
- **溫和調整範圍**——引導向較小任務但尊重使用者選擇
